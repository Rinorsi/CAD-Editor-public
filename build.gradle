import groovy.json.JsonSlurper

plugins {
    id "architectury-plugin" version "3.4.162"
    id "dev.architectury.loom" version "1.10.433" apply false
    id "me.shedaniel.unified-publishing" version "0.1.+" apply false
    id "com.github.breadmoirai.github-release" version "2.4.1"
    id "maven-publish"
    id "java"
}
//TODO 记得补上自动变更日志和矩阵发布脚本。

architectury {
    minecraft = rootProject.minecraft_version
}

subprojects {
    apply plugin: "dev.architectury.loom"

    loom {
        silentMojangMappingsLicense()
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        mappings loom.officialMojangMappings()
    }
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.mod_version

    repositories {
        mavenCentral()
        maven { url = uri("https://maven.architectury.dev/") }
        maven { url = uri("https://maven.fabricmc.net/") }
        maven { url = uri("https://maven.terraformersmc.com/releases/") }
        maven { url = uri("https://maven.neoforged.net/releases/") }
    }

    configurations.configureEach {
        resolutionStrategy.eachDependency { details ->
            if (details.requested.group == "net.fabricmc" &&
                    details.requested.name == "fabric-loader" &&
                    (details.requested.version == null || details.requested.version == "+" || details.requested.version.endsWith("+"))) {
                String loaderVersion = rootProject.hasProperty("loader_version") ? rootProject.loader_version : "0.15.11"
                details.useVersion(loaderVersion)
                details.because("Avoid dynamic fabric-loader version resolution breaking with newer JDK SAX parser restrictions")
            }
        }
    }

    java {
        toolchain { languageVersion = JavaLanguageVersion.of(21) }
        withSourcesJar()
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = "UTF-8"
        options.release.set((rootProject.hasProperty("java_version") ? rootProject.java_version : "21") as Integer)
    }

    ext {
        def slurper = new JsonSlurper()
        def versionsFile = rootProject.file("versions.json")
        def versionsMap = versionsFile.exists() ? slurper.parse(versionsFile) : [:]

        def verKey = (project.version ?: "").toString()
        def versionInfo = (versionsMap instanceof Map) ? versionsMap[verKey] : null

        versionInfoType = (versionInfo instanceof Map && versionInfo.type) ? versionInfo.type : "release"
        versionInfoChangelog = (versionInfo instanceof Map && versionInfo.changelog) ? versionInfo.changelog : "No changelog for ${verKey}"

        def compatRaw = rootProject.hasProperty("compatible_minecraft_versions") ? rootProject.compatible_minecraft_versions : '[]'
        compatibleGameVersions = slurper.parseText(compatRaw as String) as List<String>

        curseforgeProjectId = "1352735"
        modrinthProjectId  = "MJW1h2CF"
    }

    base {
        archivesName = "${rootProject.archives_base_name}-${rootProject.minecraft_version}"
    }

    tasks.withType(Jar).configureEach {
        from(rootProject.file('LICENSE')) {
            into('META-INF')
        }
        from(rootProject.file('ATTRIBUTION.txt')) {
            into('META-INF')
        }
        from(rootProject.file('README.md')) {
            into('META-INF')
        }

        manifest {
            attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Implementation-Vendor': rootProject.hasProperty('maven_group') ? rootProject.maven_group : ''
            )
        }
    }

    afterEvaluate {
        tasks.matching { it.name == 'remapJar' || it.name.endsWith('RemapJar') }.configureEach { t ->
            try {
                t.from(rootProject.file('LICENSE')) {
                    into('META-INF')
                }
                t.from(rootProject.file('ATTRIBUTION.txt')) {
                    into('META-INF')
                }
                t.from(rootProject.file('README.md')) {
                    into('META-INF')
                }
            } catch (Throwable ignored) {
            }
        }
    }
}

githubRelease {
    setToken(findProperty("github_token") as String ?: System.getenv("GITHUB_TOKEN") ?: "")
    setOwner(findProperty("github_owner") as String ?: System.getenv("GITHUB_OWNER") ?: "skyecodes")
    setRepo("CAD-Editor")

    setTagName("${version}+${rootProject.major_minecraft_version}")
    setTargetCommitish(findProperty("git_branch") as String ?: System.getenv("GIT_BRANCH") ?: "")
    setReleaseName("CAD Editor v${version} for Minecraft ${rootProject.minecraft_version}")
    setBody(versionInfoChangelog)
    setPrerelease(versionInfoType == "release")

    afterEvaluate {
        def nf = project.findProject(":neoforge")
        if (nf != null && nf.plugins.hasPlugin("dev.architectury.loom")) {
            try {
                def prov = nf.tasks.named("remapJar").flatMap { t -> t.archiveFile }
                setReleaseAssets(prov.get().asFile)
            } catch (Throwable ignored) {}
        }
    }
}
